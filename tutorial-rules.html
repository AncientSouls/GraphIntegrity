<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tutorial: Семантические права и правила - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="GraphSpreading.html">GraphSpreading</a><ul class='methods'><li data-type='method'><a href="GraphSpreading.html#addPathGraph">addPathGraph</a></li><li data-type='method'><a href="GraphSpreading.html#spreadByPathLink">spreadByPathLink</a></li><li data-type='method'><a href="GraphSpreading.html#spreadFromSpreadLink">spreadFromSpreadLink</a></li><li data-type='method'><a href="GraphSpreading.html#spreadFromSpreadLinkByPathGraph">spreadFromSpreadLinkByPathGraph</a></li><li data-type='method'><a href="GraphSpreading.html#spreadFromSpreadLinkByPathLink">spreadFromSpreadLinkByPathLink</a></li><li data-type='method'><a href="GraphSpreading.html#spreadNewSpreadLink">spreadNewSpreadLink</a></li><li data-type='method'><a href="GraphSpreading.html#unspreadByPathId">unspreadByPathId</a></li><li data-type='method'><a href="GraphSpreading.html#unspreadFromRemovedSpreadLinkByPrevId">unspreadFromRemovedSpreadLinkByPrevId</a></li></ul></li><li><a href="PathGraph.html">PathGraph</a></li><li><a href="SpreadGraph.html">SpreadGraph</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-rules.html">Семантические права и правила</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">Tutorial: Семантические права и правила</h1>
    

    <section>

<header>
    

    <h2>Семантические права и правила</h2>
</header>

<article>
    <h5>Подготовка графов</h5><p>Объявим все необходимые графы. Данные будут &quot;воображаемые&quot; и представлены только в качестве идентификаторов <code>'users/*'</code> и <code>'items/*'</code>.</p>
<pre class="prettyprint source lang-js"><code>import { Graph } from 'ancient-graph/lib/adapters/object.js';
import { PathGraph, SpreadGraph, GraphSpreading } from 'ancient-graph-spreading';

var rules = new Graph(
  [],
  { id: 'id', source: 'source', target: 'target', author: 'author' },
  (index, link) => { return 'rules/'+index; }
);

var rights = new Graph(
  [],
  { id: 'id', source: 'source', target: 'target', prev: 'prev', path: 'path', root: 'root', rule: 'rule' },
  (index, link) => { return 'rights/'+index; }
);

var nesting = new Graph(
  [],
  { id: 'id', source: 'source', target: 'target' },
  (index, link) => { return 'nesting/'+index; }
);

var nestingPathGraph = new PathGraph(nesting, 'source', 'target');
var rightsSpreadGraph = new SpreadGraph(rights, 'source', 'target', (spreadLink, pathGraph, pathLink, newSpreadLink, callback) => {
  callback(newSpreadLink);
});</code></pre><p>Допустим при создании пользователей наше приложение для него автоматически создаёт право.</p>
<pre class="prettyprint source lang-js"><code>rights.insert({ source: 'users/0', target: 'users/0' }); // 'rights/0'
rights.insert({ source: 'users/1', target: 'users/1' }); // 'rights/1'
rights.insert({ source: 'users/2', target: 'users/2' }); // 'rights/2'</code></pre><p>Допустим мы хотим что бы это право наследовалось на все вложенные в <code>'users/0'</code> элементы. Для этого мы будем наблюдать за изменениями графа вложенности и поддерживал распространение графа <code>rights</code> по графу <code>nesting</code>.</p>
<pre class="prettyprint source lang-js"><code>nestingPathGraph.graph.on('link', (oldLink, newLink) => {
  graphSpreading.spreadByPathLink(nestingPathGraph, newLink);
});

nestingPathGraph.graph.on('unlink', (oldLink, newLink) => {
  graphSpreading.unspreadByPathId(oldLink.id);
});</code></pre><p>Будет логично так-же следить за изменениями в графе прав, и продолжать их распространение или удаление.</p>
<pre class="prettyprint source lang-js"><code>rightsSpreadGraph.graph.on('link', (oldLink, newLink) => {
  if (!oldLink || oldLink[rightsSpreadGraph.variableField] != newLink[rightsSpreadGraph.variableField]) {
    graphSpreading.spreadFromSpreadLink(newLink);
  }
});

rightsSpreadGraph.graph.on('unlink', (oldLink, newLink) => {
  if (!newLink || oldLink[rightsSpreadGraph.variableField] != newLink[rightsSpreadGraph.variableField]) {
    graphSpreading.unspreadFromRemovedSpreadLinkByPrevId(oldLink.id);
  }
});</code></pre><h5>Пользователь и его собственность</h5><p>Допустим пользователь создал <code>'items/0'</code>.
Допустим система позволяет делать с не вложенными куда-либо, свободными, данными что угодно и кому угодно.
Допустим пользователь вкладывает <code>'items/0'</code> в себя.</p>
<pre class="prettyprint source lang-js"><code>nesting.insert({ source: 'users/0', target: 'items/0' }); // 'nesting/0'</code></pre><p>Это приводит к асинхронному вызову события <code>insert</code> для графа <code>nesting</code>.
В результате появляется связь <code>rights/1</code></p>
<pre class="prettyprint source lang-js"><code>rights.fetch({ target: 'items/0' });
// [{ id: 'right/1', source: 'users/0', target: 'items/0', prev: 'rights/0', path: 'nesting/0', root: 'rights/0' }]</code></pre><p>// Повторим это несколько раз что бы создать более сложное дерево вложенности.</p>
<pre class="prettyprint source lang-js"><code>nesting.insert({ source: 'items/0', target: 'items/1' }); // 'nesting/1'
nesting.insert({ source: 'items/1', target: 'items/2' }); // 'nesting/2'
nesting.insert({ source: 'users/0', target: 'items/3' }); // 'nesting/3'
nesting.insert({ source: 'items/3', target: 'items/4' }); // 'nesting/4'</code></pre><p>При этом кроме связей вложенности от каждой вершины в графе <code>nesting</code> будет существовать связь в графе <code>rights</code> ведущая к <code>'users/0'</code> как к владельцу.</p>
<p>В результате получится примерно такое дерево вложенности:</p>
<ul>
<li><code>'users/0'</code> with <code>'rights/0'</code><ul>
<li><code>'items/0'</code> with <code>'rights/3'</code> by <code>'nesting/0'</code><ul>
<li><code>'items/1'</code> with <code>'rights/4'</code> by <code>'nesting/1'</code><ul>
<li><code>'items/2'</code> with <code>'rights/6'</code> by <code>'nesting/2'</code></li>
</ul>
</li>
</ul>
</li>
<li><code>'items/3'</code> with <code>'rights/5'</code> by <code>'nesting/3'</code><ul>
<li><code>'items/4'</code> with <code>'rights/7'</code> by <code>'nesting/4'</code></li>
</ul>
</li>
</ul>
</li>
<li><code>'users/1'</code> with <code>'rights/1'</code></li>
<li><code>'users/2'</code> with <code>'rights/2'</code></li>
</ul>
<h5>Подготовка правил</h5><p>Допустим правило это желание пользователя предоставить права другому пользоватулю. Наличие правила не значит что будет предоставлено право. Право должно предоставляться только если у пользователя создавшего правило есть права на каждую вершину в дереве от указанной вершини и ниже. При этом если дерево <code>nesting</code>, <code>rights</code> или <code>rules</code> меняется нужно удостоверится что уже выданные права лигитимны, и нельзя распротраниться на новые данные.</p>
<p>Добавим к имеющимся реакциям повторный анализ выданных по некоторому правилу прав.</p>
<pre class="prettyprint source lang-js"><code>rightsSpreadGraph.graph.on('unlink', (oldLink, newLink) => {
  if (!newLink || oldLink[rightsSpreadGraph.variableField] != newLink[rightsSpreadGraph.variableField]) {
    rules.each({ target: oldLink[rightsSpreadGraph.variableField] }, undefined, (rule) => {
      // If rule illegal, then remove all rights of this rule
      rightsSpreadGraph.graph.fetch({
        [rightsSpreadGraph.constantField]: rule.author,
        [rightsSpreadGraph.variableField]: rule.target
      }, undefined, (error, rightLinks) => {
        if (!rightLinks.length) {
          rightsSpreadGraph.graph.remove({ rule: rule.id });
        }
      });
    });
  }
});</code></pre><p>Добавим реакции на изменения правил.</p>
<pre class="prettyprint source lang-js"><code>rules.on('insert', (oldLink, newLink) => {
  graphSpreading.spreadNewSpreadLink({
    [rightsSpreadGraph.constantField]: newLink.source,
    [rightsSpreadGraph.variableField]: newLink.target,
    rule: newLink.id
  });
});

rules.on('remove', (oldLink, newLink) => {
  rights.remove({ rule: oldLink.id });
});

rules.on('update', (oldLink, newLink) => {
  if (oldLink.source != newLink.source) {
    rightsSpreadGraph.update({
      rule: oldLink.id,
      [rightsSpreadGraph.constantField]: newLink.source,
    });
  } else {
    rights.remove({ rule: oldLink.id });
    graphSpreading.spreadNewSpreadLink({
      [rightsSpreadGraph.constantField]: newLink.source,
      [rightsSpreadGraph.variableField]: newLink.target,
      rule: newLink.id
    });
  }
});</code></pre><h5>Передача прав</h5><p>Допустим <code>'users/0'</code> решил предоставить <code>'users/1'</code> права на данные от <code>'items/1'</code> и глубже по дереву <code>nesting</code>.</p>
<pre class="prettyprint source lang-js"><code>rules.insert({ source: 'users/1', target: 'items/1', author: 'users/0' }); // 'rules/0'</code></pre><p>Посмотрим какие права после этого существуют для <code>'users/1'</code>:</p>
<pre class="prettyprint source lang-js"><code>rights.fetch({ source: 'users/1' });
/**
 * [
 *   { id: 'rights/1', source: 'users/1', target: 'users/1' },
 *   { id: 'rights/8', source: 'users/1', target: 'items/1', rule: 'rules/0' },
 *   { id: 'rights/9', source: 'users/1', target: 'items/2', prev: 'rights/8', path: 'nesting/2', root: 'rights/8' },
 * ]
 */</code></pre><h5>Передача переданных прав</h5><p>Допустим появился пользователь <code>'users/2'</code>.
Допустим <code>'users/1'</code> решил предоставить <code>'users/2'</code> права на данные от <code>'items/2'</code> и глубже по дереву <code>nesting</code>.</p>
<pre class="prettyprint source lang-js"><code>rules.insert({ source: 'users/2', target: 'items/2', author: 'users/1' }); // 'rules/1'</code></pre><p>Посмотрим какие права после этого существуют для <code>'users/2'</code>:</p>
<pre class="prettyprint source lang-js"><code>rights.fetch({ source: 'users/2' });
/**
 * [
 *   { id: 'rights/2', source: 'users/2', target: 'users/2' },
 *   { id: 'rights/10', source: 'users/2', target: 'items/2', rule: 'rules/1' },
 * ]
 */</code></pre><h5>Удаление правила</h5><blockquote>
<p>В этом примере можно опустить возможность распространять права на правила.</p>
</blockquote>
<p>Допустим пользователь <code>'users/0'</code> решил отобрать права предоставленные <code>'users/0'</code>.</p>
<pre class="prettyprint source lang-js"><code>rules.remove('rules/0');</code></pre><p>Это значит что право <code>'rights/7'</code> и все унаследованные связи считающие его корнем (<code>'rights/8'</code>), более не лигитимны. Они будут удалены. При удалении <code>'rights/8'</code> сработает проверка лигитимности правила <code>'rules/1'</code>, и так-как у <code>'users/1'</code> больше нет прав на <code>'items/2'</code>, значит право не может быть предоставлено и оно будет удалено.  Иначе говоря - остануться только права выданные на <code>'users/0'</code>. Правило <code>'rules/1'</code> выданное для <code>'users/2'</code> не было удалено, однако оно больше не создаёт прав, так как его автор не имеет на это прав.</p>
<pre class="prettyprint source lang-js"><code>rights.fetch('rights/8');
// []
rights.fetch('rights/9');
// []
rights.fetch('rights/10');
// []</code></pre>
</article>

</section>

</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Sep 05 2016 08:06:36 GMT+0000 (UTC) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>