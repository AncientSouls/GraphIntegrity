<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>spreading.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="GraphSpreading.html">GraphSpreading</a><ul class='methods'><li data-type='method'><a href="GraphSpreading.html#_spreadByPathLink">_spreadByPathLink</a></li><li data-type='method'><a href="GraphSpreading.html#_spreadFromSpreadLinkByPathGraph">_spreadFromSpreadLinkByPathGraph</a></li><li data-type='method'><a href="GraphSpreading.html#_spreadFromSpreadLinkByPathLink">_spreadFromSpreadLinkByPathLink</a></li><li data-type='method'><a href="GraphSpreading.html#addPathGraph">addPathGraph</a></li><li data-type='method'><a href="GraphSpreading.html#spreadByPathLink">spreadByPathLink</a></li><li data-type='method'><a href="GraphSpreading.html#spreadFromSpreadLink">spreadFromSpreadLink</a></li><li data-type='method'><a href="GraphSpreading.html#spreadFromSpreadLinkByPathGraph">spreadFromSpreadLinkByPathGraph</a></li><li data-type='method'><a href="GraphSpreading.html#spreadFromSpreadLinkByPathLink">spreadFromSpreadLinkByPathLink</a></li><li data-type='method'><a href="GraphSpreading.html#spreadNewSpreadLink">spreadNewSpreadLink</a></li><li data-type='method'><a href="GraphSpreading.html#spreadTo">spreadTo</a></li><li data-type='method'><a href="GraphSpreading.html#unspread">unspread</a></li><li data-type='method'><a href="GraphSpreading.html#unspreadByPathId">unspreadByPathId</a></li><li data-type='method'><a href="GraphSpreading.html#unspreadFromRemovedSpreadLinkByPrevId">unspreadFromRemovedSpreadLinkByPrevId</a></li></ul></li><li><a href="PathGraph.html">PathGraph</a><ul class='methods'><li data-type='method'><a href="PathGraph.html#insert">insert</a></li><li data-type='method'><a href="PathGraph.html#remove">remove</a></li><li data-type='method'><a href="PathGraph.html#update">update</a></li></ul></li><li><a href="QueueSpreading.html">QueueSpreading</a><ul class='methods'><li data-type='method'><a href="QueueSpreading.html#_getGraph">_getGraph</a></li><li data-type='method'><a href="QueueSpreading.html#insertedPathLink">insertedPathLink</a></li><li data-type='method'><a href="QueueSpreading.html#insertedSpreaderLink">insertedSpreaderLink</a></li><li data-type='method'><a href="QueueSpreading.html#insertedSpreadLink">insertedSpreadLink</a></li><li data-type='method'><a href="QueueSpreading.html#mayBeEndedLaunched">mayBeEndedLaunched</a></li><li data-type='method'><a href="QueueSpreading.html#removedPathLink">removedPathLink</a></li><li data-type='method'><a href="QueueSpreading.html#removedSpreaderLink">removedSpreaderLink</a></li><li data-type='method'><a href="QueueSpreading.html#removedSpreadLink">removedSpreadLink</a></li><li data-type='method'><a href="QueueSpreading.html#updatedLaunchedUnspreadPathLink">updatedLaunchedUnspreadPathLink</a></li><li data-type='method'><a href="QueueSpreading.html#updatedLaunchedUnspreadSpreaderLink">updatedLaunchedUnspreadSpreaderLink</a></li><li data-type='method'><a href="QueueSpreading.html#updatedSourceOrTargetPathLink">updatedSourceOrTargetPathLink</a></li><li data-type='method'><a href="QueueSpreading.html#updatedSourceOrTargetSpreaderLink">updatedSourceOrTargetSpreaderLink</a></li></ul></li><li><a href="SpreaderGraph.html">SpreaderGraph</a><ul class='methods'><li data-type='method'><a href="SpreaderGraph.html#insert">insert</a></li><li data-type='method'><a href="SpreaderGraph.html#remove">remove</a></li><li data-type='method'><a href="SpreaderGraph.html#update">update</a></li></ul></li><li><a href="SpreadGraph.html">SpreadGraph</a><ul class='methods'><li data-type='method'><a href="SpreadGraph.html#_spreadingHandler">_spreadingHandler</a></li><li data-type='method'><a href="SpreadGraph.html#_unspreadingHandler">_unspreadingHandler</a></li><li data-type='method'><a href="SpreadGraph.html#insert">insert</a></li><li data-type='method'><a href="SpreadGraph.html#remove">remove</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#factoryPathGraph">factoryPathGraph</a></li><li><a href="global.html#factorySpreaderGraph">factorySpreaderGraph</a></li><li><a href="global.html#factorySpreadGraph">factorySpreadGraph</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">spreading.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import async from 'async';

/**
 * Class with methods for spread and unspread of the spreadGraph on pathGraph(s).
 * 
 * @class
 * @description `import { GraphSpreading } from 'ancient-graph-spreading';`
 */
class GraphSpreading {
  
  /**
   * @param {SpreadGraph} spreadGraph
   */
  constructor(spreadGraph) {
    this.spreadGraph = spreadGraph;
    this.pathGraphs = [];
  }
  
  /**
   * @param {PathGraph} pathGraph
   */
  addPathGraph(pathGraph) {
    this.pathGraphs.push(pathGraph);
  }
  
  /**
   * Spread by pathLink and specified fromField with available spreadLinks.
   * 
   * @oaram {string} fromField
   * @param {PathGraph} pathGraph
   * @param {PathLink} pathLink
   * @param {Object} [context]
   * @param {GraphSpreading~spreadFromSpreadLinkByPathLinkCallback} [handler]
   * @param {GraphSpreading~spreadByPathLinkCallback} [callback]
   */
  _spreadByPathLink(fromField, pathGraph, pathLink, context, handler, callback) {
    this.spreadGraph.fetch({
      [this.spreadGraph.variableField]: pathLink[fromField]
    }, undefined, (error, spreadLinks) => {
      if (spreadLinks.length) {
        var queue = async.queue((spreadLink, next) => {
          this.spreadFromSpreadLinkByPathLink(spreadLink, pathGraph, pathLink, context, handler, next);
        });
        queue.push(spreadLinks, (error) => {
          if (callback) callback();
        });
      } else {
        if (callback) callback();
      }
    });
  }
  
  /**
   * Spread by pathLink with available spreadLinks.
   * 
   * @param {PathGraph} pathGraph
   * @param {PathLink} pathLink
   * @param {Object} [context]
   * @param {GraphSpreading~spreadFromSpreadLinkByPathLinkCallback} [handler]
   * @param {GraphSpreading~spreadByPathLinkCallback} [callback]
   */
  spreadByPathLink(pathGraph, pathLink, context, handler, callback) {
    async.each(pathGraph.fromFields, (fromField, next) => {
      this._spreadByPathLink(fromField, pathGraph, pathLink, context, handler, next);
    }, callback);
  }
  
  /**
   * Optional callback.
   *
   * @callback GraphSpreading~spreadByPathLinkCallback
   */
  
  /**
   * Spread root of tree spreadLink.
   * 
   * @param {SpreadLink} newSpreadLink
   * @param {Object} [context]
   * @param {Graph~insertCallback} [callback]
   */
  spreadNewSpreadLink(newSpreadLink, context, callback) {
    this.spreadGraph._spreadingHandler(undefined, undefined, undefined, newSpreadLink, context, (newSpreadLink) => {
      if (newSpreadLink) {
        this.spreadGraph.insert(newSpreadLink, callback, context);
      } else {
        if (callback) callback();
      }
    });
  }
  
  /**
   * Spread by all available paths from spreadLink.
   * 
   * @param {SpreadLink} spreadLink
   * @param {Object} [context]
   * @param {GraphSpreading~spreadFromSpreadLinkByPathGraphHandler} [handler]
   * @param {GraphSpreading~spreadFromSpreadLinkByPathGraphCallback} [callback]
   */
  spreadFromSpreadLink(spreadLink, context, handler, callback) {
    var queue = async.queue((pathGraph, callback) => {
      this.spreadFromSpreadLinkByPathGraph(spreadLink, pathGraph, context, handler, callback);
    });
    queue.drain = () => { if (callback) callback(); }
    queue.push(this.pathGraphs);
  }
  
  /**
   * Spread by all available paths in pathGraph from spreadLink and specified fromField.
   * 
   * @param {string} fromField
   * @param {SpreadLink} spreadLink
   * @param {PathGraph} pathGraph
   * @param {GraphSpreading~spreadFromSpreadLinkByPathGraphHandler} [handler]
   * @param {GraphSpreading~spreadFromSpreadLinkByPathGraphCallback} [callback]
   */
  _spreadFromSpreadLinkByPathGraph(fromField, spreadLink, pathGraph, context, handler, callback) {
    pathGraph.fetch({
      [fromField]: spreadLink[this.spreadGraph.variableField]
    }, undefined, (error, pathLinks) => {
      var queue = async.queue((pathLink, callback) => {
        this.spreadFromSpreadLinkByPathLink(spreadLink, pathGraph, pathLink, context, handler, callback);
      });
      queue.drain = () => { if (callback) callback(); }
      queue.push(pathLinks);
    });
  }
  
  /**
   * Spread by all available paths in pathGraph from spreadLink.
   * 
   * @param {SpreadLink} spreadLink
   * @param {PathGraph} pathGraph
   * @param {GraphSpreading~spreadFromSpreadLinkByPathGraphHandler} [handler]
   * @param {GraphSpreading~spreadFromSpreadLinkByPathGraphCallback} [callback]
   */
  spreadFromSpreadLinkByPathGraph(spreadLink, pathGraph, context, handler, callback) {
    async.each(pathGraph.fromFields, (fromField, next) => {
      this._spreadFromSpreadLinkByPathGraph(fromField, spreadLink, pathGraph, context, handler, next);
    }, callback);
  }
  
  /**
   * Optional handler. If present, called with an error object as the first argument and, if no error, others arguments with results of spreading.
   *
   * @callback GraphSpreading~spreadFromSpreadLinkByPathGraphHandler
   * @param {Error} [error]
   * @param {string} [newSpreadLinkId]
   * @param {SpreadLink} [prevSpreadLink]
   * @param {PathGraph} [pathGraph]
   * @param {PathLink} [pathLink]
   */
  
  /**
   * Optional callback.
   *
   * @callback GraphSpreading~spreadFromSpreadLinkByPathGraphCallback
   */
  
  /**
   * Spread by pathLink and specified toField in pathGraph from spreadLink.
   * 
   * @param {SpreadLink} spreadLink
   * @param {PathGraph} pathGraph
   * @param {PathLink} pathLink
   * @param {Object} [context]
   * @param {GraphSpreading~spreadFromSpreadLinkByPathLinkCallback} [callback]
   */
  _spreadFromSpreadLinkByPathLink(toField, spreadLink, pathGraph, pathLink, context, callback) {
    this.spreadGraph._spreadingHandler(spreadLink, pathGraph, pathLink, {
      [this.spreadGraph.constantField]: spreadLink[this.spreadGraph.constantField],
      [this.spreadGraph.variableField]: pathLink[toField],
      prev: spreadLink.id,
      path: pathLink.id,
      root: spreadLink.root?spreadLink.root:spreadLink.id
    }, context, (newSpreadLink) => {
      if (newSpreadLink) {
        this.spreadGraph.insert(newSpreadLink, (error, id) => {
          if (callback) callback(error, id, spreadLink, pathGraph, pathLink);
        }, context);
      } else {
        if (callback) callback();
      }
    });
  }
  
  /**
   * Spread by pathLink in pathGraph from spreadLink.
   * 
   * @param {SpreadLink} spreadLink
   * @param {PathGraph} pathGraph
   * @param {PathLink} pathLink
   * @param {Object} [context]
   * @param {GraphSpreading~spreadFromSpreadLinkByPathLinkHandler} [handler]
   * @param {GraphSpreading~spreadFromSpreadLinkByPathLinkCallback} [callback]
   */
  spreadFromSpreadLinkByPathLink(spreadLink, pathGraph, pathLink, context, handler, callback) {
    async.each(pathGraph.toFields, (toField, next) => {
      this._spreadFromSpreadLinkByPathLink(toField, spreadLink, pathGraph, pathLink, context, (error, id, prev, pathGraph, pathLink) => {
        if (handler) handler(error, id, prev, pathGraph, pathLink);
        next();
      });
    }, callback);
  }
  
  /**
   * Optional handler.
   *
   * @callback GraphSpreading~spreadFromSpreadLinkByPathLinkCallback
   * @param {Error} [error]
   * @param {string} [newSpreadLinkId]
   * @param {SpreadLink} [prevSpreadLink]
   * @param {PathGraph} [pathGraph]
   * @param {PathLink} [pathLink]
   */
  
  /**
   * Optional callback. If present, called with an error object as the first argument and, if no error, the unique id of inserted spread link as the second.
   *
   * @callback GraphSpreading~spreadFromSpreadLinkByPathLinkCallback
   */
  
  /**
   * Remove spreadLinks with specific prev spreadLink id.
   * 
   * @param {string} spreadLinkId
   * @param {Object} [context]
   * @param {GraphSpreading~unspreadFromRemovedSpreadLinkByPrevIdHandler} [handler]
   * @param {GraphSpreading~unspreadFromRemovedSpreadLinkByPrevIdCallback} [callback]
   */
  unspreadFromRemovedSpreadLinkByPrevId(spreadLinkId, context, handler, callback) {
    if (handler) {
      this.spreadGraph.fetch({ prev: spreadLinkId }, undefined, (error, spreadLinks) => {
        if (error) {
          if (callback) callback(error);
        } else {
          var queue = async.queue((spreadLink, next) => {
            this.spreadGraph.remove(spreadLink.id, (error, count) => {
              handler(error, spreadLink);
              next();
            }, context);
          });
          if (callback) queue.drain = () => { callback(undefined, spreadLinks.length); }
          queue.push(spreadLinks);
        }
      });
    } else {
      this.spreadGraph.remove({ prev: spreadLinkId }, callback, context);
    }
  }
  
  /**
   * Optional handler. If present, called with an error object as the first argument and, if no error, others arguments with results of unspreading.
   *
   * @callback GraphSpreading~unspreadFromRemovedSpreadLinkByPrevIdHandler
   * @param {Error} [error]
   * @param {SpreadLink} [spreadLink]
   */
  
  /**
   * Optional callback.
   *
   * @callback GraphSpreading~unspreadFromRemovedSpreadLinkByPrevIdCallback
   * @param {Error} [error]
   * @param {number} [count]
   */
  
  /**
   * Remove spreadLinks with specific path pathLink id.
   * 
   * @param {string} pathLinkId
   * @param {Object} [context]
   * @param {GraphSpreading~unspreadByPathIdHandler} [handler]
   * @param {GraphSpreading~unspreadByPathIdCallback} [callback]
   */
  unspreadByPathId(pathLinkId, context, handler, callback) {
    if (handler) {
      this.spreadGraph.fetch({ path: pathLinkId }, undefined, (error, spreadLinks) => {
        if (error) {
          if (callback) callback(error);
        } else {
          var queue = async.queue((spreadLink, next) => {
            this.spreadGraph.remove(spreadLink.id, (error, count) => {
              handler(error, spreadLink);
              next();
            }, context);
          });
          if (callback) queue.drain = () => { callback(undefined, spreadLinks.length); }
          queue.push(spreadLinks);
        }
      });
    } else {
      this.spreadGraph.remove({ path: pathLinkId }, callback, context);
    }
  }
  
  /**
   * Optional handler.
   *
   * @callback GraphSpreading~unspreadByPathIdHandler
   * @param {Error} [error]
   * @param {SpreadLink} [spreadLink]
   */
  
  /**
   * Optional callback.
   *
   * @callback GraphSpreading~unspreadByPathIdCallback
   * @param {Error} [error]
   * @param {number} [count]
   */
  
  /**
   * Unspread all valid spreadLinks to this id.
   * 
   * @param {string} id
   * @param {Object} [context]
   * @param {GraphSpreading~unspreadToHandler} [handler]
   * @param {GraphSpreading~unspreadToCallback} [callback]
   */
  unspread(id, context, handler, callback) {
     this.spreadGraph.fetch({ [this.spreadGraph.variableField]: id }, undefined, (error, spreadLinks) => {
       if (error) {
         if (callback) callback(error);
       } else {
         var queue = async.queue((spreadLink, next) => {
           this.spreadGraph._unspreadingHandler(spreadLink, context, (permission) => {
             if (permission) {
               this.spreadGraph.remove(spreadLink.id, (error, count) => {
                 if (handler) handler(error, spreadLink);
                 next();
               }, context);
             }
           });
         });
         if (callback) queue.drain = () => { callback(undefined, spreadLinks.length); }
         queue.push(spreadLinks);
       }
     });
  }
  
  /**
   * Optional handler.
   *
   * @callback GraphSpreading~unspreadToHandler
   * @param {Error} [error]
   * @param {SpreadLink} [spreadLink]
   */
  
  /**
   * Optional callback.
   *
   * @callback GraphSpreading~unspreadToCallback
   */
  
  /**
   * Spread all spread links from all available paths to this id.
   * 
   * @param {string} id
   * @param {Object} [context]
   * @param {GraphSpreading~spreadToHandler} [handler]
   * @param {GraphSpreading~spreadToCallback} [callback]
   */
   
  spreadTo(id, context, handler, callback) {
    var queue = async.queue((pathGraph, nextPathGraph) => {
      pathGraph.fetch({
        [pathGraph.toFields[0]]: id
      }, undefined, (error, pathLinks) => {
        async.each(pathLinks, (pathLink, nextPathLink) => {
          this.spreadByPathLink(pathGraph, pathLink, context, handler, nextPathLink);
        }, function(error) {
          nextPathGraph();
        });
      });
    });
    queue.drain = () => { if (callback) callback(); }
    queue.push(this.pathGraphs);
  }
  
  /**
   * Optional handler. Fires after each processed spread link.
   * Id can be empty if the `this.spreadGraph._spreadingHandler` banned spreading.
   * 
   * @callback GraphSpreading~spreadToHandler
   * @param {Error} [error]
   * @param {string} [newSpreadLinkId]
   * @param {SpreadLink} [prevSpreadLink]
   * @param {PathGraph} [pathGraph]
   * @param {PathLink} [pathLink]
   */
  
  /**
   * Optional callback.
   *
   * @callback GraphSpreading~spreadToCallback
   */
}

export { GraphSpreading };</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Sep 15 2016 19:55:28 GMT+0000 (UTC) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
